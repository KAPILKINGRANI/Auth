<?php
//study QueryBuilder ,User.class and dummy.php together
//if u are not using prepare then sql injection is possible
class QueryBuilder
{
    protected ?PDO $pdo = null;
    protected string $table = '';
    protected ?PDOStatement $stmt = null;
    protected bool $debug;
    protected array $whereConditions = [];
    protected array $bindings = [];
    protected ?string $sqlStatement = null;

    public function __construct(DatabaseConnection $connection, bool $debug)
    {
        $this->pdo = $connection->getPdo();
        $this->debug = $debug;
    }

    public function executeDDL(string $sql): bool
    {
        try {
            return $this->pdo->exec($sql) !== false;
        } catch (PDOException $e) {
            if ($this->debug) {
                dd($e->getMessage());
            }
            dd("Error with Database! connect with Admin!");
        }
    }

    public function table(string $table): self
    {
        $this->table = $table;
        return $this;
    }

    public function delete(): bool
    {
        $this->sqlStatement = "DELETE FROM `{$this->table}`" .
            $this->bindWhereClause();
        $this->stmt = $this->pdo->prepare($this->sqlStatement);
        return $this->stmt->execute($this->bindings);
    }
    /*
    In the context of prepared statements used for database interactions,
    the colon (:) followed by a name (e.g., :username, :email) acts as a placeholder 
    for a value that will be bound later during query execution
    */

    /*
    Example:-

    $data = ['name' => 'John', 'email' => 'john@example.com']
    $this->table = 'users'
    $this->bindWhereClause() returns " WHERE id = :id"

    The resulting SQL query would be:

    UPDATE users SET `name` = :updatename, `email` = :updateemail WHERE id = :id

    */

    public function update(array $data): bool
    {
        /*
        This part extracts the keys from the provided $data array.
        These keys represent the field names that need to be updated in the database table.
        basically map is applied on the array which is generated by array_keys
        */
        $setClause = implode(", ", array_map(function ($field) {
            return "`$field` =  :update$field";
        }, array_keys($data)));

        $this->sqlStatement = "UPDATE {$this->table} SET {$setClause}" . $this->bindWhereClause();
        $this->stmt = $this->pdo->prepare($this->sqlStatement);
        $this->bindValues($data);
        return $this->stmt->execute($this->bindings);
    }

    protected function bindValues(array $data): void
    {
        foreach ($data as $key => $value) {
            $this->bindings["update$key"] = $value;
        }
    }

    public function first(): array | bool
    {
        $this->limit(0, 1);
        $data = $this->get();
        return !empty($data) ? $data[0] : false;
    }
    // In the context of prepared statements, :key is a placeholder used to represent a value that will be bound later during execution
    // Instead of directly embedding user-provided data into the SQL query, the code uses placeholders (e.g., :key) to mark where the values should go.
    // This separates the query structure from the actual data, preventing malicious code injection

    public function insert(array $data): bool
    {
        $keys = array_keys($data);
        $fields = "`" . implode("`, `", $keys) . "`";
        $placeholders = ":" . implode(", :", $keys);
        $sql = "INSERT INTO {$this->table} ({$fields}) VALUES ({$placeholders})";

        $this->stmt = $this->pdo->prepare($sql);

        return $this->stmt->execute($data);
    }

    /*
    $user->where('name', '=', 'John')
     ->where('email', 'LIKE', '%@example.com');

    $this->whereConditions would now contain:
    ["`name` = :name", "`email` LIKE :email"]

    $this->bindings would contain:
    ["name" => "John", "email" => "%@example.com"]
    
    */

    /*
    $field` $operator :$field" -> example:- username = :username
    jab php run karega tabhi :username key ke corresponding value bindings se leke replace krega which will form actual where condition.
    */
    public function where(string $field, string $operator, string $value): self
    {
        $this->whereConditions[] = "`$field` $operator :$field";
        $this->bindings[$field] = $value;
        return $this;
    }

    //select will be used for without where conditions
    public function select(string $fields = "*"): self
    {
        if ($this->sqlStatement === null) {
            $this->sqlStatement = "SELECT $fields FROM `{$this->table}`" . $this->bindWhereClause();
        }
        return $this;
    }

    //actually this wrapper of select only with where conditions
    public function get(): array
    {
        $this->select();
        $this->stmt = $this->pdo->prepare($this->sqlStatement);
        $this->stmt->execute($this->bindings);
        $data = $this->stmt->fetchAll(PDO::FETCH_ASSOC);

        $this->reset();

        return $data;
    }

    public function count(): int
    {
        $this->select("COUNT(*) as count");
        $data = $this->get();
        return $data[0]['count'];
    }

    public function limit(int $offset, int $limit): self
    {
        $this->select();
        $this->sqlStatement .= " LIMIT $offset, $limit";
        return $this;
    }

    public function exists(array $data): bool
    {
        foreach ($data as $key => $value) {
            $this->where($key, '=', $value);
        }
        return $this->count();
    }

    protected function reset(): void
    {
        $this->stmt = null;
        $this->whereConditions = [];
        $this->bindings = [];
        $this->sqlStatement = null;
    }

    protected function bindWhereClause(): string
    {
        if (empty($this->whereConditions)) {
            return '';
        }
        return " WHERE " . implode(' AND ', $this->whereConditions);
    }
}
